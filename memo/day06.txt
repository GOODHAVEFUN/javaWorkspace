day06
복습 -> 메소드 ->클래스 ->생성자 -> this,this()

0. 복습
	new => heap
	변수 => stack
	
	
메소드
	기능
	클래스안에 선언되어있으면 메소드
	
메소드 정의
	메소드 밖에서 정의
	
	리턴타입 메소드명(자료형 매개변수)
	{
		실행할 문장;
		return 리턴값;
	}
	
메소드 정의 순서
	1. 기능을 생각한다
		({1, 2, 3, 4, 5}배열의 합을 더하는 기능)
		
	2. 리턴타입을  생각한다(void)
		void
	3. 기능에 맞는 메소드명을 작성한다
		void totalArray(){}
		
	4. 매개변수를 생각한다
		void totalArray(int[] arr){}
		
	5. 실행할 문장을 생각한다
		void totalArray(int[] arr){
			int sum = 0; //합을 저장할 변수
			for(int i : arr){
				sum+=i;
			}	
		}
		
	6. 리턴값을 생각한다
		int totalArray(int[] arr){
			int sum = 0; //합을 저장할 변수
			for(int i : arr){
				sum+=i;
			}
			return sum;	
		}	
	

메소드 사용(호출)
	메소드 안에서 사용
	
	매개변수	리턴값
	x		x	메소드명()
	o		x	메소드명(인수)
	x		o	변수 = 메소드명()
				syso(변수)
	o		o	syso(메소드명(인수);


메소드를 사용하는 이유
	1. 중복된 코드 제거
	2. 높은 재사용성
	3. 유지보수에 유리함

메소드와 메모리
   메소드는 실행되면 메모리의 Stack 영역에 메소드 실행에 필요한 저장공간이 생성된다
   메소드 내부에서 선언한 변수(지역변수, 매개변수)들의 저장공간이 생성된다
   메소드 코드가 모두 실행되어 종료되면 Stack 영역에서 해당 메소드의 저장공간이 삭제된다
   (메모리 해제)
   지역변수의 저장공간이 사라지므로 지역변수는 사용이 불가능하다

메소드의 인수와 매개변수
   인수(Argument)   메소드를 사용(호출)할 때 메소드의 매개변수로 전달될 값
   매개변수(Parameter) 외부에서 전달받아 값을 저장하고 메소드 내에서 사용될 변수

   1. 메소드의 인수와 매개변수는 반드시 타입과 일치하거나 자동형변환이 가능한 타입이어야한다
   2. return되는 값은 반드시 return 타입과 일치하거나 자동형변환이 가능한 타입이어야한다

메소드의 오버로딩(Overloading)
	매개변수의 개수 또는 타입이 다르면 같은 이름의 메소드로 선언할 수 있다
	반환타입은 오버로딩에 영향을 주지않는다
	
메소드 오버로딩 사용이유
	동일한 기능의 메소드를 정의할 때 다양한 입력값(매개값)을 받기 위해서 사용한다
	프로그램이 커지면 메소드가 많아지게 되는데 이 때 동일한 메소드를 매개값에 따라 다르게 이름을 정의 하면
	 고나리하기 어려워
	
Call by Value와 Pass by Value
	매개변수를 전달하는 방식
	
	call by value (값에 의한 호출)
		메소드에 매개변수를 전달할 때 전달되는 값의 복사본이 매개변수로 전달된다
		기본데이터나
		
2. 클래스
   객체 지향 프로그래밍(OOP : Object Oriented Programming)
      추상화된 클래스로 객체를 만들고 객체들간의 관계를 맺어 상호작용하는 프로그래밍 기법

   추상화(객체 모델링)
      공통적인 특징을 파악하여 하나의 묶음으로 만들어내는것

클래스
   1. 사용자 정의 타입이다(자료형)
      클래스를 사용하면 여러 타입, 여러 값을 저장할 수 있는 저장공간을 만들 수 있다
      클래스 안에 선언된 변수를 사용하고 싶다면 해당 클래스타입으로 객체를 선언해야한다   

   2. 연관성있는 저장공간과 기능을 한곳에 모아 편하게 관리할 수 있는 것
      저장공간과 기능을 나누어 관리하게 되면 코드가 길어졌을 때 사용하기 불편하다
      연관되는 저장공간과 기능을 클래스로 묶어서 관리 할 수 있다

   3. 객체를 생성하기 위한 틀, 설계도
      공통되는 속성(변수, 필드)과 행위(메소드)를 한번만 선언해 놓고 가져다 사용 할 수 있도록 설계한다
      추상적인 것(클래스)를 구체화 시키면(메모리에 생성된 것) 객체라고 한다

객체(Object)와 인스턴스(Instance)
   객체(Object)
      클래스를 기반으로 생성된 실체(실제 사물 또는 개념)
      객체는 클래스의 인스턴스를 말하며 메모리에 할당되어 변수와 메소드를 가짐
      
   인스턴스(Instance)
      클래스를 기반으로 실제로 생성된 객체를 인스턴스
      클래스를 메모리에 할당시킨것이며 물리적으로 존재하는 공간
   
   객체는 인스턴스보다 큰 범주에 있다
   클래스와의 관계를 말할 때 인스턴스라고 부른다

클래스 선언
   class 클래스명{
      변수; //멤버변수, 필드, 전역변수

      메소드(){} //멤버메소드

      //class를 구성하는 모든 변수, 메소드를 합쳐서 멤버라고한다
   }      

객체화작업(인스턴스화)
   객체를 만드는 작업, 추상적인 개념을 구체화 시키는 작업
   클래스명 객체명 = new 클래스명();
   클래스명 참조변수 = new 생성자;

객체 사용 방법
   객체명.멤버명;
   객체명.메소드명();

   .(마침표) : 하위 연산자, 멤버접근 연산자, 닷 연산자
   
   class MeTest{
      void method1(){}
   }
   
   class Main{
      main(){
      
      MeTest       refVar       =    new MeTest();
      자료형(클래스)   참조변수      대입연산자   new 생성자();
      -----------------------     ----------   ---------------
         1번         3번      2번   

      }
   }


   1번 : refVar라는 참조변수는 메소드영역에서 만들어진 지역변수이므로 JVM이 관리하는 메모리의 stack영역에 생성된다
      데이터 타입(클래스)은 참조하려는 대상과 같은 자료형이어야하므로 MeTest라고 지정한다
   2번 : new 연산자가 Heap 메모리에 MeTest 객체를 생성하고 참조값을 가져온다(참조값 반환)
      이 때 생성자가 실행된다
   3번 : 대입연산자를 통해 오른쪽의 참조값을 왼쪽의 참조변수에 저장한다

생성자
   클래스 이름뒤에 소괄호 있는 형태, 메소드와 비슷하지만 메소드라고 부르지 않는다
   생성자는 리턴이라는 기능이 존재하지 않는다

   1. 객체를 생성할 때 실행되는 코드가 작성되어 있다
   2. 주로 해당 클래스의 필드를 초기화하는 목적으로 사용한다

기본 생성자
   public 클래스명(){}
      매개변수 없다
      클래스를 선언 시 자동으로 선언되며, 사용자가 직접 생성자를 선언하게 되면 자동으로 만들어주지않는다