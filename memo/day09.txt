day09
복습 -> casting -> 추상클래스 -> 인터페이스

0. 복습
1) 상속
	부모클래스에 있는 멤버를 자식클래스가 상속받는 것
	
상속문법
	class 부모클래스{
	}
	class 자식클래스 extends 부모클래스{
	
	}

super	부모의 참조값
	부모의 멤버에 접근할 때 사용한다
super()	부모의 생성자
	자식 클래스 타입의 객체로 부모 필드에 접근할 수 있다

다형성	하나의 것으로 여러 형태를 가진다
	오버로딩		생성자, 메소드/리턴타입은 영향을 끼치지 않는다
			매개변수의 타입, 개수, 순서
	오버라이딩		메소드 / 상속관계, 한번만
			
2) 접근제한자
	public		모든 곳에서 접근 가능
	protected	다른 패키지에서 접근 불가, 자식은 허용
	default		다른 패키지에서 접근 불가
	private		다른 클래스에서 접근 불가, 메소드(getter, setter)

1. Casting
	상속관계를 맺은 클래스끼리 캐스팅이 가능하다
	up casting	자식 값을 부모 타입으로 형변환
	down casting	이미 up casting 된 객체를 자식타입으로 형변환
	* 부모 값을 자식 타입으로 형변환 시 오류 발생
	* 자식 클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다!

Casting을 사용하는 이유
	부모 타입인 하나의 저장공간에 여러 자식 타입의 참조값을 Up Casting하여 저장할 수 있다
	(참조변수의 다형성)
	만약 하나의 기능을 하는 메소드를 만들 때 매개변수로 여러 자식 타입을 받아야한다고 가정해보자
	Casting이 없다면 자식타입을 매개변수로 받는 메소드를 타입별로 각각 만들어야한다
	(자식끼리는 타입이 다르기 때문)
	Casting을 활용하면 부모 타입의 매개변수를 가진 하나의 메소드만 만들면 된다
	(부모 타입의 참조변수로 모든 자식타입을 저장할 수 있기 때문에)

	** 주의사항 **
	1. Up casting 으로 자식 참조값을 저장했다면 자식 클래스에 Override(재정의)한 기능이 실행된다
	2. Up casting 으로 자식 참조값을 저장했다면 자식클래스에 새로 구현한 기능들은 사용할 수 없다
	   이 경우 Down casting을 통해서 복구하고 사용한다

다형성
	하나의 것으로 여러가지 형태를 가질 수 있는 성질
	1. 오버로딩(생성자, 메소드)
	2. 오버라이딩(메소드-상속)
	3. 참조 변수의 다형성(매개변수의 다형성)
		조상 클래스 타입의 참조 변수로 자손 클래스 객체를 가리키는 것을 허용함

객체 간 타입 비교
	instanceof	
	a instanceof A	: 조건식, 참 또는 거짓 중 하나가 나오는 식
		a가 A 타입이면 true
		a가 A 타입이 아니면 false

2. 추상클래스
	클래스를 구성하는 멤버 중 추상 메소드가 존재한다라는 뜻

추상메소드
	메소드를 선언만 하고 구현하지 않은 것을 추상 메소드라고한다(미완성된 메소드)

	abstract 리턴타입 메소드명(자료형 매개변수);
	1) abstract 키워드를 사용한다
	2) 마지막에 세미콜론을 쓴다

일반메소드
	클래스{
	리턴타입 메소드명(자료형 매개변수){
		실행할 코드;
	}
	}

추상 클래스
	abstract 키워드가 붙은 클래스는 추상클래스이며, 추상 메소드가 한개이상 있는 클래스는
	반드시 추상클래스로 선언되어야한다(미완성된 클래스)

	abstract class 클래스명{
		abstract 리턴타입 메소드명(자료형 매개변수,..);
		* 일반 메소드도 선언 가능
	}	

	1) abstract 키워드를 사용한다
	2) 객체화 시킬 수 없다
	
	※ 미완성된 메소드(추상메소드)는 상속받은 자식 클래스에서 반드시 재정의하여 구현을 해야만
	해당 클래스를 객체화 할 수 있다
	그러므로 [강제성]을 부여하기 위해 추상 메소드로 선언한다

추상클래스를 사용하는 이유
	공통되는 속성과 행위를 추상화하여 부모 클래스를 만드는데 반드시 모든 자식클래스에서 구현해야하는
	메소드가 있다면 추상메소드로 선언하는게 좋다
	추상 클래스를 상속받은 자식클래스는 추상 메소드를 오버라이딩(재정의) 하지않으면 오류가 발생하므로
	강제성이 생기게 된다
	만약 부모클래스에서 메소드를 구현한다면 강제성이 없으므로 자식클래스를 만드는 개발자가 재정의하지않고
	그냥 넘어갈 수 있다

3. 인터페이스(Interface)
	일종의 추상클래스이지만 클래스라고 부르지 않으며 추상화의 정도가 높다
	멤버로 상수와 추상메소드만 가질수있다
	인터페이스는 객체화 할 수 없다
	인터페이스는 다른 클래스에서 구현(implements)해서 사용한다(상속과 비슷하다)

인터페이스 멤버 : 상수, 추상메소드	
추상클래스 멤버 : 일반메소드, 추상메소드, 필드, 생성자

인터페이스의 선언
	interface 인터페이스명{
		멤버
		상수, 추상메소드
	}	

인터페이스의 멤버
	1. 모든 변수는 상수다 public static final 이다 (생략해도 자동으로 붙음)
	2. 모든 메소드는 추상메소드다 public abstract 이다 (생략해도 자동으로 붙음)































