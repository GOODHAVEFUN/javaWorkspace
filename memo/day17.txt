day17
과제풀이 -> 쓰레드

+) 배열과 컬렉션 프레임워크의 차이

1. 유연성 : HashMap 크기를 동적으로 조정가능
     배열 크기를 고정적으로 사용함
2. 키-값 저장 : Key-Value가 한쌍으로 저장하는 자료구조, 각 요소에 고유한 key를 지정하여 값을 찾거나 수정가능
   배열 index로 사용함
3. 수정과 검색이 빠름

4. 메모리 사용량 : HashMap 크기 조정이 유연하게 가능함
      배열의 크기가 커질경우 불필요한 메모리가 사용됨

1. 쓰레드
   프로그램   특정 작업을 수행하는 명령어(소스코드)들의 모음
   프로세스  실행중인 프로그램, 자원과 쓰레드
   쓰레드   작업을 처리하는 것

단일쓰레드(싱글쓰레드)
   Main 쓰레드
   하나의 쓰레드만 가지고 있기 때문에 작업을 순차적으로 처리하므로 비효율적이다
   안정성이 높고, 설계가 쉽다

멀티쓰레드
   메인쓰레드가 작업을 마치더라도 다른 쓰레드의 작업이 모두 끝나야 프로그램이 종료된다
   하나의 프로세스에서 여러 작업을 동시에 처리하는 것처럼 느껴지지만 사실은 각각의 쓰레드를 매우 빠른 속도로
   번갈아가면서 실행시켜서 조금씩 처리한다
   쓰레드간 공유하는 자원이 있다면 충돌이 생겨 문제가 발생할 수 있으며 이런 문제를 동기화(Synchronized)로 해결한다
   안정성이 떨어지고 설계가 굉장히 어렵다

멀티쓰레드 구현방법
   1. Thread 클래스 상속
   2. Runnable 인터페이스 구현

   start() 새로운 쓰레드를 만들고 작동시킬수 있다 => 쓰레드를 실행시킨다
   run()   쓰레드가 처리할 작업을 재정의한다
멀티쓰레드 구현방법
   1. Thread 클래스 상속
   2. Runnable 인터페이스 구현

   start() 새로운 쓰레드를 만들고 작동시킬수 있다 => 쓰레드를 실행시킨다
   run()   쓰레드가 처리할 작업을 재정의한다


   Threa thread = new Trhead(){
      @Override
      public void run(){
         //쓰레드가 실행할 코드
      }
   };
   thread.start();

쓰레드 이름
   Thread.currentThread().getName()
   디버깅할 때 어떤 쓰레드가 작업을 하는지 조사할 목적으로 주로 사용됨
   현재 코드를 어떤 쓰레드가 실행하고 있는지 확인하려면 정적메소드인 currentThread()로 쓰레드의 객체의 참조값을
   얻은 다음 getName() 메소드로 이름을 출력함

   메인쓰레드 : main
   작업쓰레드 : Thread-n 의 이름을 가진다
   작업 쓰레드의 이름을 다른 이름으로 설정하고 싶다면 Thread 클래스의 setName() 메소드를 사용하면 됨
   thread.setName("쓰레드이름");

멀티쓰레드 관련 메소드
	1. run()	쓰레드를 호출하는 메소드
	2. start()	쓰레드를 실행시키면, run()메소드를 호출한다
	3. sleep(long millis)	매개변수로 전달한 시간동안 쓰레드를 멈춘다
	4. join() join(long millis)
		현재 쓰레드의 작업을 멈추고 join()를 사용한 쓰레드를 기다린다
     		매개변수에 값을 전달하지 않으면 현재 쓰레드가 join을 사용한 쓰레드의 작업이 끝날때까지 기다린다
     		매개변수에 값을 전달하면 해당 시간동안 기다렸다가 현재 쓰레드를 다시 실행한다
     		보통 먼저 실행시킬 쓰레드에 사용한다

+) 백엔드 웹개발에서 쓰레드 사용
   1. 동시 요청 처리 : 웹 서버는 여러 클라이언트로부터 동시에 요청을 받을 수 있고 각 요청 독립적으로 처리되어야함
   2. 비동기 작업 처리 : 데이터 베이스 쿼리, 외부 API 호출, 파일 입출력
         비동기적으로 처리하기 위해 쓰레드가 사용됨
   3. 백그라운드 작업 : 정기적으로 데이터 처리, 캐시를 생성하거나, 로그작업 등
   4. 병렬 처리 : 데이터 병합을 해야된다면 각 데이터 소스를 별도의 쓰레드에서 처리하여 병렬로 데이터 가져올 수 있음
   

쓰레드 동작과정
   Thread 클래스 상속 또는 Runnable 인터페이스를 통해 run() 메소드 구현
   쓰레드 객체 생성
   start() 메소드 호출
   쓰레드 실행
   쓰레드 종료

쓰레드 상태
   쓰레드는 생성된 후부터 종료될때까지 여러 상태를 가질 수 있다

   상태      설명
   NEW      쓰레드가 생성되고 아직 start() 가 호출되지 않은 상태
   RUNNABLE   실행 중 또는 실행 가능한 상태
   BLOCKED      동기화 블록에 의해서 일시정지된 상태(lock이 풀릴때까지 기다리는 상태)
   WAITING,   쓰레드의 작업이 종료되지 않았지만 실행가능하지 않은(unrunnable) 일시정지 상태,
   TIMED_WAITING   TIMED_WAITING 일시정지 시간이 지정된 경우를 의미
   TERMINATED   쓰레드의 작업이 종료된 상태

   객체생성 -> start() 호출 -> 실행 -> 실행 대기 -> 실행 -> 실행완료
   NEW -> RUNNABLE -> RUNNING -> WAITING/BLOCKED / TIMED_WAITING ->RUNNING -> TERMINATED

   쓰레드에서 처리할 로직을 run() 메소드에서 구현하고
   Thread 클래스의 start() 메소드를 이용해 실행
   -> 실행 대기 상태로 들어감(JVM의 스케줄링에 의해 실행할 수 있는 상태)
   -> 자바 프로그램은 JVM에 의해 실행되는 쓰레드가 결정되며 이것을 스케줄링이라고 한다

멀티쓰레드의 최대 단점 : 교착상태(DeadLock)
   멀티쓰레드 중 쓰레드 간에 대기 상태가 종료되지 않아서 무한정 대기만 하는 상태 
   교착상태인지를 판단했다면 전체 쓰레드를 깨워주거나 하나의 쓰레드를 종료시켜주면 교착상태가 해결된다

동기화(Synchronization)
   A쓰레드와 B쓰레드가 작업을 진행할 때 A가 사용중인 자원을 B가 사용하여 변경한다면 A의 작업의도와 다르게
   결과가 나타날수있다
   이것을 방지하기 위해 하나의 자원을 여러 쓰레드가 동시에 접근하지 못하게 막는 것을 동기화 라고한다

동기화 영역 만들기
   synchronized(객체명) { ... } : 동기화 블록
      일부 소스코드만 동기화를 걸어준다
      쓰레드는 지정된 객체의 lock을 얻어내며 해당 객체의 lock을 가진 쓰레드만 동기화 블록에
      접근이 가능하다

   synchronized 메소드명(){ ... } : 동기화 메소드
      해당 메소드 전체에 동기화를 걸어준다