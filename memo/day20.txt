day20
총 복습 -> 컬렉션 프레임워크 문제 풀이 -> 과정 -> 문제 

1. 상속(Inheritance)
	재사용
	그룹화

super	부모의 참조값
super() 부모의 생성자

casting
	Up casting	자식 값을 부모 타입으로 형변환
			다양한 타입을 한번에 관리하기 위해서
	Down casting	up casting 된 객체를 자식 타입으로 형변환
			자식 클래스의 필드나 메소드를 사용해야하는 경우

접근권한제어자
	default		다른 패키지 접근 불가
	public		모든 곳에서 접근 가능
	protected	자식 클래스에서 허용, 다른 패키지 접근 불가
	private 	다른 패키지 접근불가, 메소드(getter, setter)

추상클래스
	멤버 : 필드, 추상메소드, 일반메소드
	추상 메소드가 1개 이상 있는 클래스
	abstract
	사용이유 : 강제성을 부여하기 위해서

인터페이스
	interface
	멤버 : 상수(public static final), 추상메소드(public abstract)
		default, static, private
	사용이유 : 표준화, 그룹화(마커인터페이스)

어댑터클래스
	인터페이스의 강제성을 없애주고 자식 클래스에서 상속받아 필요한 메소드만 재정의하여 사용한다

다중구현(o), 다중상속(x)	
	implement 인터페이스명1, 인터페이스명2

단일상속
	extends 클래스명

모호성(ambiguity)
	하나의 자식이 여러 부모를 상속받을 때 부모 필드에 동일한 이름의 필드가 있다면
	어떤 부모의 필드인지 알 수 없다

해결방안
	1) 두 개의 인터페이스내에 같은 이름과 매개변수의 메소드가 선언되어있다
		=> 자식 클래스에서 재정의하여 사용한다
	2) 부모 클래스의 메소드와 인터페이스의 디폴트메소드의 이름과 매개변수가 같다
		=> 부모 클래스의 메소드가 사용된다

마커 인터페이스(Marker Interface)
	클래스들을 그룹화 하기 위한 목적으로 사용
	인터페이스는 지정한 클래스의 부모이며, 모든 자식은 부모 타입으로 마커 인터페이스를 지정받은 클래스들이
	하나의 타입으로 묶이게 된다
	=> 상속은 단일 상속밖에 되지 않으므로 인터페이스를 사용

내부클래스(Inner Class)
	클래스 내부에 선언된 클래스
	외부클래스 : 내부클래스를 가진 클래스

	인스턴스 내부 클래스 : 다른 클래스 내부에 선언되는 클래스
			-> 외부 클래스의 인스턴스와 연관이 있음
	스태틱 내부 클래스 : 다른 클래스 내부에 선언되는 클래스
			-> 외부 클래스의 인스턴스와 상관없이 독립적으로 사용 될 수 있음
	로컬 내부 클래스 : 메소드나 초기화 블록내부에서 선언되는 클래스
			-> 선언된 블록 내에서만 사용가능

익명클래스(Anonymouse inner class)
	이름이 없는 클래스
	미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해 사용한다

	ClassA ca = new ClassA(){
		//오버라이딩
	}; //;은 참조값이기 때문에 붙여줘야한다

람다식(Lambda Expression) : 익명메소드
	함수형 인터페이스 : 단 하나의 추상메소드를 가지고 있는 인터페이스
			@FunctionalInterface

	람다식을 사용할 때는 람다식을 저장하기 위한 참조변수의 타입을 결정해야한다
	람다식을 하나의 변수에 대입할 때 사용하는 참조 변수의 타입을 함수형 인터페이스라고 부른다

예외처리
	예상되는 예외를 적절한 처리를 하여 비정상적인 종료를 막는다
	
	발생시점	확인된 예외 : 컴파일 단계에서 발생하는 예외
		미확인 예외 : 프로그램 실행 중(런타입) 발생하는 예외

예외 클래스	Exception
	메소드 	getMessage() : 예외 메세지를 문자열로 반환
	 	printStackTrace() : 예외가 발생지점을 추적하여 단계별로 전부 출력함
		toString() : 발생한 예외 객체를 문자열로 반환

예외처리를 하는 이유 : 프로그램의 안정성을 높이고, 신뢰성 있는 프로그램을 만들기 위함

	throw : 예외를 발생시키기
	throws : 예외 던지기, 메소드의 선언부에 사용함
		-> 해당 메소드를 사용하는 개발자가 상황에 맞게 처리하기 위함
	
API(Application Programming Interface)
	어플리케이션 개발에 필요한 것들을 가져다 쓸수있게 해주는 중간다리(매개체)

	내부 API : JDK 설치시 제공해주는 기본 API
	외부 API : 다른 개발자들이 개발한 패키지 및 클래스들을 의미함
	API 주석 
		/**~*/
		@author 작성자
		@since  JDK 버전 설명
		@parma	메소드 매개변수
		@return 반환값
		<br>	줄바꿈
		<b> <li> html 태그를 이용해서 설명 기재

Object 클래스
	모든 클래스의 최상위 부모 클래스

	toString()	: 참조값을 문자열형태로 출력
			클래스 경로 이름@16진수로 변환된(해쉬코드)
	equals()	: 주소값 비교, 문자열 비교
			객체를 비교하고 싶다면 비교기준을 재정의해서 사용할 수 있다
	hashCode()	: 객체의 주소값을 특정 알고리즘을 거쳐서 정수값으로 반환
			equals() 재정의하면 hashCode()도 재정의하도록 권장

Wrapper Class
	기본 자료형들의 클래스 타입

	기본형은 변수의 값을 그대로 저장
	참조형은 객체의 레퍼런스를 저장
	참조형에는 객체가 할당되어야하는데 기본형과 달리 사이즈가 유동적이라 Heap 영역에 별도 메모리공간을
	차지하고 할당한 뒤 참조변수는 해당 Heap영역의 주소값을 가리키게 된다

boxing	: 기본 타입의 값을 Wrapper 클래스의 객체로 변환
unboxing : Wrapper 클래스 객체에서 기본 타입의 값으로 변환

컬렉션프레임워크(Collection Framework) : 자료구조
	List
	Set
	Map

List 
	데이터 순서 보장, 중복 허용	

구현 클래스
	ArrayList : 추가, 삭제는 상대적으로 느리지만 검색(탐색)이 빠르다

제네릭
	<E> : Element 제네릭
		타입 안정성을 보장하기 위한 기능
		
	사용이유 : 필드의 타입별로 클래스를 만들어야한다
		Object 타입을 사용한다면 다운캐스팅을 해야한다
		제네릭은 타입을 제한할 수 있다

배열과 ArrayList의 차이
	배열은 길이에 제한을 둘 때 사용
	ArrayList 몇개의 데이터가 들어올지 알수없을 때 사용

Set
	데이터 순서보장하지않음, 중복 허용하지 않음

구현클래스
	HashSet

Iterator
	컬렉션에 저장된 데이터들을 컬렉션 종류와 상관없이 동일한 방식으로 가져오기 위한 인터페이스(타입)
	iterator()	컬렉션 객체를 Iterator 타입으로 변환할 때 사용하는 메소드
	hasNext()	다음 값의 유무를 검사하여 boolean 타입으로 반환
	next()		다음 값을 가져오기, 값이 없다면 예외가 발생한다

HashSet 주의사항
	hashCode()를 사용하는 HashSet에 객체를 저장할 때 equals()를 재정의했다면
	hashCode()도 재정의해야한다

Map
	데이터 순서 보장하지 않는다
	데이터를 key-value 한 쌍으로 저장하며 key로 데이터에 접근 가능
	key는 중복허용하지 않음

구현클래스
	HashMap

Hash	데이터를 다루는 기법
	key-value로 이루어져있고
	key를 Hash 함수에 넣어 특정 정수값을 산출한다(해싱(Hasing))
	얻어낸 정수값을 bucket이라는 배열의 인덱스 번호로 사용하여 value를 저장한다

쓰레드
	하나의 프로세스 내에서 작업을 처리하는 흐름의 단위
	
	프로그램 : 특정 작업을 수행하는 명령어들의 모음
	프로세스 : 실행중인 프로그램
		프로그램을 실행시키기 위한 자원과 쓰레드로 구성된다
		자원 - h/w 자원, s/w 자원
		
싱글쓰레드(단일)
	하나의 쓰레드가 작업을 마치면 프로그램이 종료된다
	쓰레드를 하나만 가지고 있기 때문에 순차적으로 작업을 처리한다
	안정성이 높고, 설계가 쉽다
	상대적으로 비효율적이다	

멀티쓰레드(다중)
	메인쓰레드가 작업을 마쳐도 다른 쓰레드의 작업이 모두 끝나야만 프로그램이 종료된다
	쓰레드간 공유 자원이 있다면 충돌이 생겨 문제 발생가능성이 있다(동기화로 해결)
	안정성이 떨어지고 설계가 어렵다

멀티쓰레드 구현방법
	Thread  클래스 상속
	Runnable 인터페이스 구현

쓰레드 상태
	객체 생성 -> start() 호출 -> 실행 -> 실행대기 -> 실행 -> 실행완료
	NEW -> RUNNABLE -> RUNNING -> WAITING/TIME_WAITED/BLOCKED -> RUNNING -> TERMINATED

멀티쓰레드의 단점
	1. 교착상태(DeadLock)
	2. 자원공유(동기화)

동기화 영역
	동기화 블록
		synchronized(객체명) {...}
	동기화 메소드
		synchronized 메소드명() {...}

lock
	자바의 모든 객체는 하나의 lock을 가지고 있다
	쓰레드가 공유되는 자원을 사용할 때 생기는 문제를 동기화로 해결한다
	하나의 자원에 하나의 쓰레드 접근하기 위해 사용되는 개념이 lock이다

파일입출력
	입출력 : 프로그램 내부의 데이터 프로그램 외부의 데이터를 주고받는 것
		내부의 데이터 : 변수, 배열, 객체 등
		외부의 데이터 : 내부 데이터를 제외한 모든 것

	자바프로그램 기준으로 읽기, 쓰기

스트림(stream)
	데이터를 주고받는 통로, byte로 전송됨

버퍼(buffer)
	임시 저장공간

스트림과 버퍼
	버퍼에 저장했다가 일정 데이터가 쌓이면 한번에 전송한다 -> 전송속도가 빠르다

스트림 종류
	기본 스트림 : 실제 데이터를 주고받는 스트림
	보조 스트림 : 기능을 향상시키는 스트림

Stream 스트림 클래스
	배열, 컬렉션 같은 데이터 묶음을 효율적으로 처리하기위해 제공되는 API





-----------------------------------------------------------------------
과정소개
	JAVA
	DBMS(Orcle) -> MySQL(Maria)
	JDBC(Coneection)
	HTML(인라인요소, 블록요소, 인라인-블록요소, 시맨틱태그)
	CSS(웹 앱 반응형) / 미디어쿼리
	JavaScript(호이스팅, 프로토타입, 객체, 이벤트, DOM)
	JSP(MySQL, MVC 패턴)
	SPA(Single page Application)
		Ajax 비동기 통신
	JSON(구글에서 제작한 형식, 데이터 전달)
	JSP 팀프로젝트(Git-Bash, Git-Hub, SourceTree)
		=> 팀 프로젝트
	Spring Boot(Oracle, DI, AOP, Transctional, 단위테스트, 검증, ..)
	Maven, Gradle
	Spring Boot 팀 프로젝트(최종)

	+ 종강 2~3일전 플젝 종료 후 발표회 및 후속작업
--------------------------------------------------------------
1. 콘솔기반 메모장 프로그램
프로그램 실행되면 새 메모 작성, 메모열기, 메모저장, 종료 중 하나를 선택해야함

1 새메모작성
	사용자가 새 메모 내용을 작성할 수 있어야함
	작성한 내용은 프로그램이 종료되기 전까지 메모리에 저장되어야함

2 메모 열기
	사용자가 파일 이름을 입력하면 해당 파일의 내용을 화면에 출력해야함
	파일이 없거나 읽기 오류가 발생하면 오류 메시지 표시

3 메모 저장
	사용자가 입력한 파일 이름으로 현재 메모리에 메모 내용을 저장함
	저장 중 오류가 발생하면 오류 메시지 표시
4 종료


2. 쇼핑몰 프로그램

Product 클래스
	상품이름(문자열), 가격(실수형) - private으로 설정
	생성자
	
ShoppingCart 클래스
	item(컬렉션프레임워크 하나 이용)
	생성자
	메소드 - addItem(장바구니에 상품추가), removeItem(장바구니에 상품삭제), displayItem(장바구니 목록확인) 

OnlineShopping 클래스
	Main메소드 사용
	
	상품 3개 추가하고 실행

	1) 상품 목록보기
	2) 장바구니에 상품 추가
	3) 장바구니 목록보기
	4) 종료































