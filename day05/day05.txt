day05
복습 -> 배열 -> 메소드

0. 복습
제어문
   조건문   if, if~else, if~else if~else / switch
   반복문   for, while, do~while
   기타제어문   continue, break

배열
   저장공간의 나열
   
배열의 선언
1) 배열 변수 선언 후 배열 생성
   자료형[] 배열명 = new 자료형[배열크기];

2) 배열 변수 선언과 함께 초기값 할당
   자료형[] 배열명 = {값1, 값2, ..};

3) 배열 변수 선언 후 배열생성과 초기화
   자료형[] 배열명;
   배열명 = new 자료형[] {값1, 값2,..};

4) 배열 생성하지 않고 배열 변수를 초기화
   자료형[] 배열명 = null;
   
   /*ArrayTast01*/
   
new    Heap 메모리에 할당, 저장공간의 시작주소를 가져온다
null   주소의 초기값(어떤 주소가 들어갈지 모를때 사용)

Runtime Data Area : JVM이 프로그램을 실행할 동안 사용하는 메모리 영역
JVM의 메모리 영역은 OS(운영체제)에게 할당받은 메모리
JVM은 메모리 공간 내에서 독자적으로 메모리를 관리하고 여러 영역으로 나누어 사용한다
JVM 메모리 영역과 운영체제의 메모리 영역은 분리되어 동작한다

Stack, Heap, Method, 프로그램 카운터 레지스터, 네이티브 메소드 스택

Stack Area
   메소드 호출 시에 사용하는 메모리 공간
   정적으로 할당된 메모리 영역
   지역변수, 매개변수 등의 데이터가 저장되며
   참조자료형(Reference Type) 변수에는 참조값이 저장된다
   => 해당 변수가 해당 객체를 참조하는 주소값을 가지고 있기 때문

Heap Area(=동적 메모리)
   객체와 배열이 생성되는 메모리 공간
   new 연산자로 생성되는 것이 저장되는 공간
   동적 메모리 할당을 사용하기 때문에 프로그램이 실행 중에 메모리의 크기를 동적으로
   조정할 수 있다
   
Method Area
   클래스의 정보, static 변수, 상수 등이 저장되는 메모리 공간
   JVM이 시작할 때 생성되며, 모든 쓰레드가 공유한다

PC Register
   현재 실행중인 명령어의 주소를 저장하는 메모리 공간
   JVM이 쓰레드를 생성할 때마다 쓰레드마다 별도의 PC Register를 가진다

Native Method Stack
   JNI(Java Native Interface)를 사용하여 호출되는 C/C++ 메소드의 스택 영역
   
Index
   배열을 생성할 때 각각의 저장공간에 자동으로 붙여지는 번호
   0부터 순차적으로 증가하면서 부여된다
   배열의 이름은 한개이기 때문에 이름만으로는 배열에 여러 저장공간에 접근할 수 없다
   index를 이용하여 각각의 저장공간에 접근한다
   배열명[index] 사용하고 하나의 저장공간이므로 변수처럼 사용한다
   
   /*ArrayTest02*/
   
length
   배열을 생성할 때 자동으로 생성되는 저장공간의 수(배열의 길이)
   배열의 길이는 한 번 만들어지면 변동될 수 없으므로 length는 상수라고 볼 수 있다
   배열명.length로 사용한다

배열의 사용
   int[] arData = {4, 1, 3, 6, 7, 10};
   syso(arData.length);   //6
   arData[0] = 10; //저장공간
   arData[1] + 9;   //값
   arData[3] = arData[0] + 10;   //저장공간, 값
   int data = arData[4];   //값

   arData[10] = 20;   //오류
   
   /*ArrayTest03*/
   /*ArrayTest04*/
   /*ArrayTest05*/
2차원 배열
	배열안에 배열
	2차원 이상의 배열은 메모리 낭비가 심해서 선호하지않는다
	
2차원 배열 선언
   자료형[][] 배열명 = new 자료형[행][열];
   자료형[][] 배열명 = {{값1, 값2}, {값1, 값2}, {값1, 값2}};

2차원 배열 길이
   배열명.length : 행의 길이
   배열명[행].length : 열의 길이
   /*TwoArray*/
   /*TwoForEach*/
   
for-each문(빠른 for문, 확장 for문)
   for(자료형 변수 : 배열명){
      실행할문장;
   }

   변수에는 배열의 요소가 한개씩 차례대로 담긴다
   (index 순서대로)
 
 16:18
 
 	자료형은 배열이나 컬랙션의 요소타입과 동일한 타입으로 지정해야한다
 	변수명은 각 요소가 저장된 변수의 이름을 지정
 배열의 구조 
 	int[] ar = new int[3];
 	 참조변수     참조값
 	
 	stack영역			heap영억
 	[첫번째 주소값]		[값1] [값2] [값3]
 		ar			 0	   1	2	->인덱스번호

3. 메소드
함수와 메소드
   클래스 밖에 선언되어 있으면 함수
   클래스 안에 선언되어 있으면 메소드

메소드
   기능
   이름뒤에 소괄호

메소드 선언과 구현(정의)
   리턴타입 메소드명(자료형 매개변수)
   {
      실행할문장;
      return 리턴값;
   }

리턴타입   반환할 값이 있다면 반환값의 자료형을 작성한다
   반환할 값이 없다면 void를 작성한다
메소드명    동사로 작성한다
매개변수   외부에서 전달받을 값이 있다면 자료형과 매개변수명 순서에 맞게 선언해준다
   전달받을 값이 없다면 매개변수 생략가능하다
실행할 문장   생략이 가능하다. 메소드의 기능을 구현하는 코드를 작성한다
retrun      생략이 가능하다. return이 실행되면 메소드가 종료된다.
      리턴값이 있다면 메소드를 사용하는 부분을 통채로 리턴값으로 본다
      리턴값이 없다면 값이 아니다

메소드의 정의와 사용
   메소드를 정의할 때는 {}중괄호가 있고 반드시 메소드 밖에서 정의한다
   메소드를 사용할 때는 {}중괄호가 없고 반드시 메소드 안에서 사용한다
   
   /*MethodTest01*/
   
메소드 정의순서
   1. 기능을 생각한다(숫자를 더해주는 기능)
   2. 반환타입을 생각한다. 생각나지 않는다면 우선 void로 작성한다
      void
   3. 기능에 알맞은 메소드명을 작성한다(가능하면 동사로 add, sum, plus)
      void add(){}
   4. 매개변수를 생각한다
      void add(int num1, int num2){}
   5. 실행할 문장을 작성한다
      void add(int num1, int num2){
         int result = num1 + num2;
      }
   6. 리턴값을 생각한다
      int add(int num1, int num2){
         int result = num1 + num2;
         return result;
      }
메소드를 정의할 때 static 키워드를 붙이는 이유
   java 프로그램을 실행하면 .java파일을 컴파일러가 해석 -> .class 파일 생성
   .class 파일을 JVM에 포함된 클래스 로더가 읽어내는데
   이 때 static 붙은 변수나 메소드를 먼저 메모리에 할당시킨다

static   어플리케이션 실행 시 먼저 메모리에 할당시킨다
   
메소드를 사용할 때 오류를 해결하는 방법 2가지
   1. static 키워드를 메소드를 정의한 쪽에 붙힌다
   2. main메소드에서 사용하는 메소드(내가 정의한 메소드)를 알려준다

      자료형 변수명 = 값;
      Scanner 객체명 = new Scanner(System.in);
   
메소드의 호출방법(4가지)
   매개변수      리턴값      호출
   x			x      메소드명();
   o    		x      메소드명(인수);
   x      		o      syso(메소드명());
   o      		o      syso(메소드명(인수);
   
   /*MethodTest02*/
   /*MethodTest03*/
